import os
from tqdm import tqdm

from neurofly.neurodb.neurodb_sqlite import NeurodbSQLite
from neurofly.backend.neuron_graph import NeuroGraph

def CC_from_db_to_graph(DB:NeurodbSQLite, nids:list):
    # read graph from database
    G_list = []
    for _nid in nids:
        nodes, edges = DB.read_connected_components(nid=_nid, with_edges=True)
        G = NeuroGraph(nodes, edges)
        G_list.append(G)
    return G_list

def graph2swc(G:NeuroGraph):
    # convert one neuron graph (with soma) to swc
    graph = G.graph
    somas = [_nid for _nid, _node_attr in graph.nodes(data=True) if _node_attr.get('type') == 1]
    if not somas:
        flag = 'error'
        logger = "No soma node in the connected component."
        return [], flag, logger
    elif len(somas) > 1:
        flag = 'error'
        logger = 'More than one soma node in the connected component.'
        return [], flag, logger
    flag = 'success'
    logger = 'Soma node found, proceeding with SWC export.'

    soma_nid = somas[0]
    kids2parent = {soma_nid: -1}
    DFS_stack = [soma_nid]
    visited_nids = set([soma_nid])
    while DFS_stack:
        curr_nid = DFS_stack.pop()
        for nbr_nid in graph.neighbors(curr_nid):
            if nbr_nid not in visited_nids:
                kids2parent[nbr_nid] = curr_nid
                visited_nids.add(nbr_nid)
                DFS_stack.append(nbr_nid)
    
    # Check for cycles or disconnected nodes
    if len(kids2parent) != graph.number_of_nodes():
        flag = 'warning'
        logger = 'Detected cycles or disconnected nodes in the graph.'
    
    SWC = ["# Generated by NeuroFly_dev\n"]
    for k_nid, p_nid in tqdm(kids2parent.items(), total=len(kids2parent), desc="Converting to SWC"):
        k_attr = graph.nodes[k_nid]
        k_coord = k_attr['coord']
        k_type = k_attr['type']
        k_radius = k_attr.get('radius', 1.0)
        
        # Format parent ID (-1 for soma)
        p_nid = p_nid if p_nid in graph else -1
        swc_line = f"{k_nid} {k_type} {k_coord[0]} {k_coord[1]} {k_coord[2]} {k_radius} {p_nid}\n"
        SWC.append(swc_line)
        
    return SWC, flag, logger

def read_swc_file(swc_path) -> list:
    with open(swc_path, 'r') as swc_file:
        SWC = swc_file.readlines()
    return SWC

def read_swc_folder(swc_folder:str) -> dict:
    swc_file_list = [_f for _f in os.listdir(swc_folder) if _f.endswith('.swc')]
    SWC_dict = {}
    for file_name in swc_file_list:
        swc_path = os.path.join(swc_folder, file_name)
        SWC = read_swc_file(swc_path=swc_path)
        SWC_dict[file_name] = SWC
    return SWC_dict

def parse_swc(SWC:list):
    NODES = {}
    for line in SWC:
        if line.startswith('#'): 
                continue
        column = line.split()
        if len(column) < 7:
            continue
        nid = int(column[0])
        n_type = int(column[1])
        x,y,z = map(float, column[2:5])
        pid = int(column[6])
        if pid == nid or pid < 0:
            pid = None
        node = NODES.get(nid, {})
        node['coord'] = [x, y, z]
        node['type'] = n_type
        node['pid'] = pid
        node['sid'] = None
        NODES[nid] = node
        if pid is not None:
            p_node_data = NODES.get(pid, {})
            p_node_data['sid'] = nid
            NODES[pid] = p_node_data
    return NODES